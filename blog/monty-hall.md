# Java Random and a bit of Monty-Hall

This article is inspired by Monty-Hall problem/paradox. Now I found this 
paradox disturbing initially (this is why it's paradox, wink...), and decided
to quickly model it to validate for myself. That brought idea of investigating
how Java Random implementation works and this article. 

Let's start with Monty-Hall...

## Monty-Hall problem and it's model

There are 3 doors and behind each is either a car or a goat. There are 2 goats 
and 1 car altogether. If you try to guess behind which door is a car, what is 
the chance of getting it right? Easy! 1 out of 3 makes 33,3% chance of getting
it right.

If someone would open a door with a goat (but not the one that you initially
chose) and ask you if you want to change your selection? Would you change your
choice or stay with initial door?  The correct answer is... if you change door 
you will have 66,6% of getting a car, but if you stay with initial choice - you 
stay with initial 33,3% chance. 

Now I though this result is awkward, because when one door opened you have 2
doors to choose, which is essentially 50/50 chance. But the model (which can be 
found [here](TODO link)) 
shows this is incorrect. So Monty-Hall problem suggests that probabilities have 
temporal linking as well, meaning probability depends on the moment when 
decision is made as well as your odds.

## Random

#### Instantiation

Random generator simply speaking is sequence generator. Random constructor 
accepts "seed" parameter which is just a starting value for the sequence 
generator. This is why if you seed 2 Random instances with same number and 
call same next() methods in exact sequence, generated number will be exactly 
the same.

To protect default Random constructor from such behavior, Java uses current
system time to seed generator. However it is possible that 2 threads will 
instantiate Random objects at exactly same nano second, therefore current time
is XOR'ed with "seed uniquifier" value which is guaranteed to be unique for 
each thread via AtomicLong#compareAndSet().

Please note, that if you need multiple threads served by random generator it might
be beneficial to use ThreadLocalRandom, that reduces thread contention.

#### Number generation

Actual "random" number generation is done by next() method as all other methods 
are just wrappers around that to create correct variable, using some bit 
arithmetic. 

The next method itself is multiplication, addition and masking with carefully
selected values that ensure good good uniformity. This means that once you 
have same bits generated by 2 random generators (which could be achieved via 
setSeed() method), next generated sequences will be exactly the same, similar 
to what is achieved by having same seed from the start.

#### Number predictability

At this point you may feel that aforementioned predictability may break security
of system, if Random is used to generate tokens, passwords, IDs, etc. In fact 
there are [ways](TODO link)
to calculate Random seed using just 2 subsequent generated values. Also since 
next() returns only 32 bytes, having longer (e.g. 128-bit) token will not 
improve security. 

#### When to use

Use Random or ThreadLocalRandom when you care only about uniformity of generated
numbers. These will give you uniform probabilities and decent performance. 

## SecureRandom

As said before biggest problem with Random is that it's reversible. To break 
this we may use cryptographically strong (requires many iterations to guess
input based on output) hashing function and apply it to generated numbers. In 
fact SecureRandom is a mini-framework to assemble you own generator from 
seeding, byte generation and hashing function.

#### Structure

SecureRandom is not a generator itself, but a Template pattern around how 
random generator must operate. It uses Java SPI functionality, that allows you 
too hook any implementation of SecureRandomSpi that would be used to actually 
generate seed and bytes. Other than that, SecureRandom operates similarly to 
Random.

In case you need to use different generators in the same application, you can
use constructors/factory methods with your implementation or Provider to get 
SecureRandom instances with different backends.

So what if you don't provide your own SPI implementation? Then SecureRandom will
fall back to default Sun implementation - sun.security.provider.SecureRandom. 
Let's further describe what this Sun implementation does to generate random 
numbers.

#### Initialization

To obtain random seed Sun implementation uses SeedGenerator object. Here you 
have 3 options:
1. You can specify a system property to read seed from your URL. In this case
URLSeedGenerator instance will be used
2. If you don't go 1st option it will attempt to use NativeSeedGenerator (more 
on this below)
3. If your OS does not support NativeSeedGenerator, it will fall back to using 
ThreadSeedGenerator, which will generate seed based on how much time OS takes
to switch between application threads.

NativeSeedGenerator is the instance that most likely to be used. 

#### Number generation

## When to use 


